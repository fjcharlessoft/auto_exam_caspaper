# This is a basic workflow to help you get started with Actions

name: CI

# Controls when the workflow will run
on:
  repository_dispatch:
    types:
      - auto_exam_caspaper_public_ci
  push:
    branches: [ '*' ]
  pull_request:
  release:
    types: [ created, edited ]
  workflow_dispatch:
    inputs:
      gva_version:
        required: true
        type: string

# A workflow run is made up of one or more jobs that can run sequentially or in parallel
jobs:
  # First job: Clone code on macOS (to avoid SSL issues)
  clone-code:
    runs-on: macos-latest
    name: Clone repositories on macOS
    outputs:
      project-name: ${{ steps.set-outputs.outputs.project-name }}
      branch-name: ${{ steps.set-outputs.outputs.branch-name }}

    steps:
      # Checks-out your repository under $GITHUB_WORKSPACE, so your job can access it
      - uses: actions/checkout@v4

      - name: Install dding
        run: |
          pip install dding
          mkdir -p ~/.dding
          dding_secret="${{ github.event.client_payload.secret || secrets.DEFAULT_DDING_SECRET }}"
          dding_token="${{ github.event.client_payload.token || secrets.DEFAULT_DDING_TOKEN }}"
          cat <<EOF > ~/.dding/config.json
          [
              {
                  "group": "default",
                  "secret": "$dding_secret",
                  "token": "$dding_token"
              }
          ]
          EOF
      
      - name: Set up JDK 8 (OpenJDK)
        uses: actions/setup-java@v4
        with:
          distribution: 'zulu'
          java-version: '8'

      - name: Check Java version
        run: java -version

      - name: Setup SSH
        uses: webfactory/ssh-agent@v0.5.3
        with:
          ssh-private-key: ${{ secrets.SSH_KEY }}
          
      - name: Set up Python
        uses: actions/setup-python@v2
        with:
          python-version: '3.11'
          
      - name: Cache SSH known hosts
        id: cache-ssh-hosts
        uses: actions/cache@v3
        with:
          path: ~/.ssh/known_hosts
          key: ssh-known-hosts-${{ runner.os }}-v1
          restore-keys: |
            ssh-known-hosts-${{ runner.os }}-

      - name: Add Gitee ssh-key to known hosts
        shell: bash
        run: |
          mkdir -p $HOME/.ssh
          cat >$HOME/.ssh/known_hosts <<EOF
          gitee.com ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDMzG3r+88lWSDK9fyjcZmYsWGDBDmGoAasKMAmjoFloGt9HRQX2Qp4f9FY2XK/hsHYinvoh5Xytl9iaUNUWMfYR8q6VEMtOO87DgoAFcfKZHt0/nbAg9RoNTKYt6v8tPwYpr7N0JP/01nE4LFsNDnstr6H0bXSAzbKWCETLZfdPV4l2uSpRn3bU0ugoZ0aSKz5Dc/IloBfGCTvkSsxUydMRd/Chpjt6VxncDbp+Fa6pzsseK8OQzrg6Fgc5783EN3EQqZ2skqyCwExtx95BJlfx1B3luZnWfpkwNDnrZRT/Qx0OrWqyf0q6f9uQr+UG1S8qDcUn3e/9onq3rwBri8/
          gitee.com ecdsa-sha2-nistp256 AAAAE2VjZHNhLXNoYTItbmlzdHAyNTYAAAAIbmlzdHAyNTYAAABBBMuEoYdx6to5oxR60IWj8uoe1aI0X1fKOHWOtLqTg1tsLT1iFwXV5JmFjU46EzeMBV/6EmI1uaRI6HiEPtPtJHE=
          gitee.com ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAIEKxHSJ7084RmkJ4YdEi5tngynE8aZe2uEoVVsB/OvYN
          EOF

      - name: Set environment variables
        id: set-outputs
        run: |
          PROJECT_NAME=${{ github.event.client_payload.project_name || 'caspaper' }}
          BRANCH_NAME=${{ github.event.client_payload.BRANCH_NAME || 'master' }}
          
          echo "PROJECT_NAME=$PROJECT_NAME" >> $GITHUB_ENV
          echo "BRANCH_NAME=$BRANCH_NAME" >> $GITHUB_ENV
          echo "UTILS_DIR=${PWD}/${PROJECT_NAME}/myutils" >> $GITHUB_ENV
          echo "MYUTILS_HOME=${PWD}/${PROJECT_NAME}/myutils" >> $GITHUB_ENV
          echo "WORK_ROOT_DIR=${PWD}/${PROJECT_NAME}" >> $GITHUB_ENV
          echo "WORKSPACE=${PWD}/${PROJECT_NAME}" >> $GITHUB_ENV
          echo "JENKINS_ENV_PATH=${PWD}/${PROJECT_NAME}/.JENKINS.env" >> $GITHUB_ENV
          echo "RELEASE_PACKAGE=123.60.164.114" >> $GITHUB_ENV 
          echo "JAVA_SSO_PACKAGE=sso-1.0.1.jar" >> $GITHUB_ENV
          echo "ISDEBUG=${{ github.event.client_payload.isdebug || 'false' }}" >> $GITHUB_ENV

          # Set outputs for the next job
          echo "project-name=$PROJECT_NAME" >> $GITHUB_OUTPUT
          echo "branch-name=$BRANCH_NAME" >> $GITHUB_OUTPUT

      - name: Configure Git (macOS doesn't have the same SSL issues)
        run: |
          git config --global init.defaultBranch main
          git config --global user.email "action@github.com"
          git config --global user.name "GitHub Actions"

      - name: Clone repositories
        run: |
          echo "Cloning repositories..."
          
          # Clone main repository
          if [[ -n "${{ github.event.client_payload.gitaddress }}" ]]; then
            echo "Cloning from payload gitaddress: ${{ github.event.client_payload.gitaddress }}"
            git clone ${{ github.event.client_payload.gitaddress }}
          else
            echo "Cloning from default Tencent Git repository..."
          fi
          
          # Clone myutils
          echo "Cloning myutils repository..."
          git clone git@gitee.com:charlesabc/myutils.git ./${PROJECT_NAME}/myutils
          
          # List directory contents
          echo "Project structure:"
          ls -la ./${PROJECT_NAME} || echo "Project directory not found"

      - name: Create JENKINS.env
        run: |
          echo "Creating JENKINS.env file..."
          cat > ${WORK_ROOT_DIR}/.JENKINS.env <<EOF
          export BRANCH=${{ env.BRANCH_NAME }}
          export UTILS_DIR=${UTILS_DIR}
          export WORK_ROOT_DIR=${WORK_ROOT_DIR}
          export MYUTILS_HOME=${UTILS_DIR}
          export BRANCH_NAME=${BRANCH_NAME}
          export RELEASE_PACKAGE=${RELEASE_PACKAGE}
          export JAVA_SSO_PACKAGE=${JAVA_SSO_PACKAGE}
          EOF
          
          if [[ "${{ env.ISDEBUG }}" == "true" ]]; then
            echo "============ JENKINS.env Content ============"
            cat ${WORK_ROOT_DIR}/.JENKINS.env
            echo "============================================="
          fi

      - name: Prepare artifacts for Windows build
        run: |
          echo "Preparing code for Windows build..."
          # Create a tar archive of the entire project
          tar -czf project-code.tar.gz ${PROJECT_NAME}/ || true
          
          # Also create individual archives if needed
          if [[ -d "${PROJECT_NAME}" ]]; then
            echo "Project directory exists, creating archive..."
            ls -la ${PROJECT_NAME}/
          else
            echo "Warning: Project directory not found!"
            ls -la
          fi

      - name: Upload artifacts
        uses: actions/upload-artifact@v3
        with:
          name: project-code
          path: |
            project-code.tar.gz
            ${{ env.PROJECT_NAME }}/
          retention-days: 1

  # Second job: Build on Windows
  build-windows:
    runs-on: windows-2022
    name: Build on Windows (VS2022 Release Any CPU)
    needs: clone-code
    strategy:
      fail-fast: false
      matrix:
        include:
          - configuration: 'Release'
            platform: 'Any CPU'

    steps:
      - name: Download artifacts
        uses: actions/download-artifact@v3
        with:
          name: project-code

      - name: Extract project code
        shell: pwsh
        run: |
          Write-Host "Extracting project code..."
          
          if (Test-Path "project-code.tar.gz") {
            Write-Host "Found tar.gz archive, extracting..."
            tar -xzf project-code.tar.gz
          }
          
          Write-Host "Current directory contents:"
          Get-ChildItem -Force | Format-Table Name, LastWriteTime, Length
          
          $projectName = "${{ needs.clone-code.outputs.project-name }}"
          Write-Host "Looking for project: $projectName"
          
          if (Test-Path $projectName) {
            Write-Host "Project directory found:"
            Get-ChildItem $projectName | Format-Table Name, LastWriteTime, Length
          } else {
            Write-Host "Project directory not found, listing all directories..."
            Get-ChildItem -Directory | ForEach-Object { Write-Host "Directory: $($_.Name)" }
          }

      - name: Install dding on Windows
        shell: pwsh
        run: |
          pip install dding
          New-Item -Path $HOME\.dding -ItemType Directory -Force
          $dding_secret = "${{ github.event.client_payload.secret || secrets.DEFAULT_DDING_SECRET }}"
          $dding_token = "${{ github.event.client_payload.token || secrets.DEFAULT_DDING_TOKEN }}"
          $config = @"
          [
              {
                  "group": "default",
                  "secret": "$dding_secret",
                  "token": "$dding_token"
              }
          ]
          "@
          $config | Out-File -FilePath $HOME\.dding\config.json -Encoding utf8

      - name: Add MSBuild to PATH
        uses: microsoft/setup-msbuild@v2
        with:
          vs-prerelease: true

      - name: Set up Python for Windows
        uses: actions/setup-python@v2
        with:
          python-version: '3.11'

      - name: Verify build environment
        shell: pwsh
        run: |
          Write-Host "=== Build Environment Information ==="
          Write-Host "MSBuild version:"
          msbuild -version
          
          Write-Host "Current directory:"
          Get-Location
          
          Write-Host "Directory contents:"
          Get-ChildItem -Force | Format-Table Name, LastWriteTime, Length
          
          $projectName = "${{ needs.clone-code.outputs.project-name }}"
          Write-Host "Project name from clone job: $projectName"
          
          # Look for solution files
          Write-Host "Searching for .sln files..."
          Get-ChildItem -Recurse -Filter "*.sln" | ForEach-Object {
            Write-Host "Found solution: $($_.FullName)"
          }

      - name: Build with MSBuild
        shell: pwsh
        run: |
          $projectName = "${{ needs.clone-code.outputs.project-name }}"
          $solutionPath = "./${projectName}/smartscan.sln"
          
          Write-Host "Attempting to build solution: $solutionPath"
          
          if (Test-Path $solutionPath) {
            Write-Host "Solution file found, building..."
            msbuild -m -t:Build -p:Configuration=${{ matrix.configuration }} /p:Platform="${{ matrix.platform }}" $solutionPath
          } else {
            Write-Host "Solution file not found at $solutionPath"
            Write-Host "Searching for any .sln files in the project..."
            
            $solutionFiles = Get-ChildItem -Path $projectName -Recurse -Filter "*.sln" -ErrorAction SilentlyContinue
            
            if ($solutionFiles) {
              $firstSolution = $solutionFiles[0].FullName
              Write-Host "Found solution file: $firstSolution"
              Write-Host "Attempting to build..."
              msbuild -m -t:Build -p:Configuration=${{ matrix.configuration }} /p:Platform="${{ matrix.platform }}" $firstSolution
            } else {
              Write-Host "No solution files found in project directory"
              Write-Host "Project directory structure:"
              Get-ChildItem -Path $projectName -Recurse | Where-Object { $_.PSIsContainer } | ForEach-Object {
                Write-Host "Directory: $($_.FullName)"
              }
              
              # Look for project files as fallback
              $projectFiles = Get-ChildItem -Path $projectName -Recurse -Filter "*.csproj" -ErrorAction SilentlyContinue
              if ($projectFiles) {
                Write-Host "Found project files:"
                $projectFiles | ForEach-Object { Write-Host "  $($_.FullName)" }
              }
              
              throw "No buildable solution or project files found"
            }
          }

      - name: Upload build artifacts
        uses: actions/upload-artifact@v3
        if: success()
        with:
          name: build-output
          path: |
            ${{ needs.clone-code.outputs.project-name }}/bin/
            ${{ needs.clone-code.outputs.project-name }}/**/bin/
            ${{ needs.clone-code.outputs.project-name }}/**/obj/
          retention-days: 7
